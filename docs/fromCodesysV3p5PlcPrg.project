PROGRAM PLC_PRG
VAR
	// Original Xeryon variables
 	drive1Enable : BOOL;
	drive1EnableOld : BOOL;
 	drive1Index : BOOL;
 	drive1MoveAbs : BOOL;	
 	drive1Dpos : BOOL;		
 	drive1Halt : BOOL;
 	drive1Stop : BOOL;	
 	drive2ResetEncoder : BOOL;	
	drive1ResetEncoder : BOOL;	
	drive1Reset : BOOL;
	
	drive1State : INT;
	drive1Target : BOOL;

	drive1Speed : DINT := 10000; //10000
	drive1Acc :  DINT := 65000; //65535
	drive1Dec :  DINT := 65000; //65535
	drive1ErrorString: STRING;
	
	drive2Enable : BOOL;
	drive2EnableOld : BOOL;
	drive2Index : BOOL;
	drive2MoveAbs : BOOL;		
	drive2Dpos : BOOL;	
	drive2Halt : BOOL;
	drive2Stop : BOOL;	
	drive2Reset : BOOL;	

	drive2State : INT;
	drive2Target : BOOL;

	drive2Speed : DINT := 10000;
	drive2Acc :  DINT := 65000;
	drive2Dec :  DINT := 65000;
	target_min : DINT;
	target_max : DINT;
	
 	drive2ErrorString: STRING;

	dpos: DINT;
	Halt: INT;

	// CUSTOM VARS
	temperature_reading : REAL; //temperature reading
	systemState : INT := 0; // system state
	// Status variables to see if drive status is busy, waiting, or in error
	drive1Status : XeryonDriveStatus; 
	drive2Status : XeryonDriveStatus;
	// Boolean variables to use if there is errors
	drive1Error : BOOL;
	drive2Error : BOOL;
	targetPanEnc : DINT; // target value in encoder unit
	targetTiltEnc : DINT; 
	
	Axis1Params : AxisParams := (Speed := 10000, Acc := 65000, Dec := 65000); // organized axis params into structure
    Axis2Params : AxisParams := (Speed := 10000, Acc := 65000, Dec := 65000);
	
	// Custom function blocks initialization
	fbInit : InitDrives; // enable and  initialize drives
	fbIndex : IndexDrives; // index drives
	fbGenerateSpiral : GenerateSpiral; //generate spiral
	fbExecuteSpiral : ExecuteSpiral;   // Function block for spiral scan
	fbFindPeak   : FindPeakPower; // finds the peak power
	fbFigure8Scan: Figure8Scan; // figure 8 scan
	
	initMotors : BOOL := TRUE;
	indexMotors : BOOL := FALSE;
	// Beam scan variables
	firstSpiralExecuted : BOOL := FALSE; //ensure the starting spiral position is used only for the first scan
	startSpiral  : BOOL := FALSE; // Manual trigger to start spiral
	peakPanDeg   : LREAL := 0.0; //initialize
    peakTiltDeg  : LREAL := 180.0;  //initialize
	startPanDeg   : LREAL := -2.3; //initialize
    startTiltDeg  : LREAL := 177.9;  //initialize 
	CenterPan : LREAL; //initialize
    CenterTilt : LREAL;
	CenterPanC3 : LREAL; //initialize
    CenterTiltC3 : LREAL;
	MIN_POWER_THRESHOLD : REAL := 70.0; //minimum power threshold for power 
	PathBuffer : ARRAY [0..599] OF PathPoint; // Array to hold the generated path
	currentScanPoint : INT := 0; // Index for the execution FB
	spiralPointsCount : DINT := 0; // Number of points generated by fbGenerateSpiral
	firstScan : BOOL := TRUE; // This auto-resets every cold start (non-retained)
	drivePeakMoveSent : BOOL := FALSE;
	tiltError: DINT;
	panError: DINT;
	waitStart : BOOL := FALSE;
	HoldTimer : TON;              // Timer for hold duration at peak
    HOLD_TIME   : TIME := T#10S;    // Desired hold duration (adjustable)
	WaitTimer_State2 : TON;              // Timer for wait duration before start
	WaitTimer_State3 : TON;
	WaitTimer_State4 : TON;
	WaitTimer_State5 : TON;
	WaitTimer_State6 : TON;
	WaitTimer_State7 : TON;
	PowerSettleTimer : TON;
	LossTimer : TON; // restart scan if lost signal 
    WAIT_TIME   : TIME := T#1S;   
	holdMoveSent : BOOL := FALSE;
	generateSent : BOOL := FALSE;
	startGenerateC3 : BOOL := FALSE;
	startFindPeak : BOOL := FALSE;
	startFig8 : BOOL := FALSE;
	doneFig8 : BOOL := FALSE;
	powerSettle : BOOL := FALSE;
	GlobalMaxPower_uW : REAL; // Define the absolute highest power ever seen.
END_VAR

VAR CONSTANT
    ENC_TOL : DINT := 100; // allowed position error in encoder counts
END_VAR
IF firstScan THEN //current link position 178.6, -2.45
    systemState := 0;
// 	peakPanDeg := -2.6; //initialize as 0
//     peakTiltDeg := 178.2;  //initialize as 180
// 	startPanDeg  := -2.34; //initialize as 0
//     startTiltDeg := 178.4;  //initialize as 180
	startPanDeg  := -2.2; //initialize as 0
    startTiltDeg := 178.4;  //initialize as 180
    firstScan := FALSE;
END_IF
// Define the drives
GVL.Drive1();
GVL.Drive2();
drive1ErrorString := TO_STRING(GVL.Drive1.Error);
drive2ErrorString := TO_STRING(GVL.Drive2.Error);
GVL.encReadingDegTilt := GVL.Drive1.ActPosition / ((2 * 3.14159265359) / 360 * 1000000 / ((2*3.14159265359*1E6)/1843200)); // last number is encoder resolution
GVL.encReadingDegPan := GVL.Drive2.ActPosition / ((2 * 3.14159265359) / 360 * 1000000 / ((2*3.14159265359*1E6)/1843200)); // last number is encoder resolution
GVL.power_uw := Custom_I2C_Power_Sensor.Power_uW;

CASE systemState OF
	0: //Enable motors and Initialize
		IF initMotors THEN
			fbInit(Drive1 := GVL.Drive1, Drive2 := GVL.Drive2);
		END_IF
		
		IF fbInit.Done THEN
			initMotors := FALSE;
			indexMotors := TRUE;
			systemState := 1;
		END_IF
	1: // Index (Home motors)
		IF indexMotors THEN
			fbIndex(Drive1 := GVL.Drive1, Drive2 := GVL.Drive2, Axis1 := Axis1Params, Axis2 := Axis2Params);
		END_IF
		
		IF fbIndex.Done THEN
			indexMotors := FALSE;
			systemState := 2;
		END_IF
	2: // Move to starting position
		IF NOT drive1MoveAbs THEN
       	 	targetTiltEnc := dposDegToEnc(startTiltDeg);
			GVL.Drive1.MoveAbsolute(targetTiltEnc, drive1Speed, DINT_TO_UINT(drive1Acc), DINT_TO_UINT(drive1Dec));
			drive1MoveAbs := TRUE;
		END_IF
	
		IF NOT drive2MoveAbs THEN
			targetPanEnc := dposDegToEnc(startPanDeg);
			GVL.Drive2.MoveAbsolute(targetPanEnc, drive2Speed, DINT_TO_UINT(drive2Acc), DINT_TO_UINT(drive2Dec));
			drive2MoveAbs := TRUE;
		END_IF
	
		// Check if drives are done
		IF GVL.Drive1.Done AND drive1MoveAbs THEN
			drive1MoveAbs := FALSE;
		END_IF
		IF GVL.Drive2.Done AND drive2MoveAbs THEN
			drive2MoveAbs := FALSE;
			waitStart := TRUE;
		END_IF
		WaitTimer_State2(IN := waitStart, PT := T#1S);
		
		// Check for errors
		IF GVL.Drive1.HasError OR GVL.Drive2.HasError THEN
			systemState := 10; // go to restart/error handling
		END_IF
	
		IF WaitTimer_State2.Q THEN
			waitStart := FALSE;
			WaitTimer_State2(IN := FALSE);
			systemState := 3;
		END_IF
		
	3: // GENERATE SPIRAL PATTERN
		startGenerateC3 := FALSE;
		IF NOT generateSent THEN
            // 1. CHOOSE CENTER AND LOCK IT IN
			IF NOT firstSpiralExecuted THEN
				// Use initial start position and flag completion
				CenterPanC3 := startPanDeg;
				CenterTiltC3 := startTiltDeg;
			ELSE
				// Use the best peak position found
				CenterPanC3 := peakPanDeg;
				CenterTiltC3 := peakTiltDeg;
			END_IF
            startGenerateC3 := TRUE;
			fbGenerateSpiral(StartGenerate := startGenerateC3, CenterPan := CenterPanC3, CenterTilt := CenterTiltC3, PathData := PathBuffer);
			generateSent := TRUE;
			currentScanPoint := 0; 
		ELSE
			startGenerateC3 := FALSE;
			fbGenerateSpiral(StartGenerate := startGenerateC3, CenterPan := CenterPanC3, CenterTilt := CenterTiltC3, PathData := PathBuffer);
		END_IF
		
		spiralPointsCount := fbGenerateSpiral.PointsCount;
        IF fbGenerateSpiral.Done THEN
			generateSent := FALSE;
			waitStart := TRUE;
        END_IF
		
		WaitTimer_State3(IN := waitStart, PT := T#1S);
    	IF WaitTimer_State3.Q THEN
			waitStart := FALSE;
			WaitTimer_State3(IN := FALSE);
			startSpiral := TRUE;
			startGenerateC3 := FALSE;
			GVL.LogActive := TRUE;
			GVL.LogIndex := 0;
			systemState := 4; // Move to Execute Scan
		END_IF
	4: // EXECUTE SPIRAL SCAN (Point-to-Point)
		IF NOT startSpiral THEN
			startSpiral := TRUE;
		END_IF
        fbExecuteSpiral(
            Drive1 := GVL.Drive1, Drive2 := GVL.Drive2, Axis1 := Axis1Params, Axis2 := Axis2Params,
            StartMove := startSpiral, CurrentPower_uW := GVL.power_uw, Min_Power_uW := MIN_POWER_THRESHOLD,
            PathData := PathBuffer, PointsCount := spiralPointsCount,CurrentIndex := currentScanPoint);
		// Exit if we get a hit of power above the min threshold
        IF GVL.power_uw >= MIN_POWER_THRESHOLD THEN
            // 1. HALT drives immediately
            GVL.Drive1.Halt();
            GVL.Drive2.Halt();
            
            // 2. Capture current position as the new starting peak for Figure 8
            peakTiltDeg := GVL.encReadingDegTilt; // Use the current encoder reading
            peakPanDeg := GVL.encReadingDegPan;
            
            // 3. Set flags to transition to Figure 8 (State 7)
            startSpiral := FALSE; // Stop the spiral FB
            firstSpiralExecuted := TRUE;
            GVL.LogActive := FALSE; 
            waitStart := TRUE; // Start the transition timer
        END_IF

		WaitTimer_State4(IN := waitStart, PT := WAIT_TIME);
        IF fbExecuteSpiral.Done AND NOT fbExecuteSpiral.Executing THEN
			firstSpiralExecuted := TRUE;
			GVL.LogActive := FALSE;
			waitStart := TRUE;
        END_IF
		IF WaitTimer_State4.Q THEN
			WaitTimer_State4(IN:=FALSE);
			waitStart := FALSE;
			startSpiral := FALSE;
			// Check if we found a peak or completed the scan
            IF GVL.power_uw >= MIN_POWER_THRESHOLD THEN
				GVL.LogActive := TRUE;
				GVL.LogIndex := 0;
				GlobalMaxPower_uW := GVL.power_uw;
				startFig8 := TRUE;
                systemState := 7; // Found a signal, go straight to Figure 8
            ELSE
                // Completed scan, but no strong signal. Must still go to State 5 to analyze
                // the log data for the best location near the threshold.
                //systemState := 5; 
            END_IF
            //systemState := 5; // Move to Peak Analysis
		END_IF
	5: // Find peak power position
		IF NOT startFindPeak THEN
			startFindPeak := TRUE;
		END_IF
		IF startFindPeak THEN
        	fbFindPeak(StartAnalysis := startFindPeak, MaxIndexToSearch := GVL.LogIndex, HistoryData := GVL.ContinuousHistoryData);
		END_IF
		WaitTimer_State5(IN := waitStart, PT := WAIT_TIME);
        IF fbFindPeak.Done THEN
			waitStart := TRUE;
        END_IF
		IF WaitTimer_State5.Q THEN
			WaitTimer_State5(IN:=FALSE);
			waitStart := FALSE;
 			// Retrieve the best position
            peakTiltDeg := fbFindPeak.PeakTiltDeg;
            peakPanDeg  := fbFindPeak.PeakPanDeg;
            
            // Reset the trigger and move to the final positioning state
            fbFindPeak.StartAnalysis := FALSE; 
			startFindPeak := FALSE;
            systemState := 6; 
		END_IF
	6: // Move to peak power position
		// Calculate target positions
		targetTiltEnc := dposDegToEnc(peakTiltDeg);
		targetPanEnc  := dposDegToEnc(peakPanDeg);
	
		// Calculate current errors
		tiltError := ABS(GVL.Drive1.ActPosition - targetTiltEnc);
		panError  := ABS(GVL.Drive2.ActPosition - targetPanEnc);
		 // If move not sent yet OR position drifted too far, re-send move command
		IF (NOT drivePeakMoveSent) OR (tiltError > ENC_TOL) OR (panError > ENC_TOL) THEN
			GVL.Drive1.MoveAbsolute(targetTiltEnc, drive1Speed, DINT_TO_UINT(drive1Acc), DINT_TO_UINT(drive1Dec));
			GVL.Drive2.MoveAbsolute(targetPanEnc, drive2Speed, DINT_TO_UINT(drive2Acc), DINT_TO_UINT(drive2Dec));
			drivePeakMoveSent := TRUE;
		END_IF
		
		PowerSettleTimer(IN := powerSettle, PT := T#150MS); // Start 50ms timer
		// Check completion condition
		IF GVL.Drive1.Done OR GVL.Drive2.Done THEN
			drivePeakMoveSent := FALSE; // Clear flag to allow re-sending command if needed later
			powerSettle := TRUE;
		END_IF
		
		IF PowerSettleTimer.Q THEN
			powerSettle := FALSE;
			PowerSettleTimer(IN := FALSE);

			IF (tiltError <= ENC_TOL) AND (panError <= ENC_TOL) THEN
				waitStart := TRUE;
			ELSE
				// Out of range — re-command the move next scan
				//drivePeakMoveSent := FALSE;
				waitStart := FALSE;
			END_IF
		END_IF
		
		WaitTimer_State6(IN := waitStart, PT := WAIT_TIME);
		IF WaitTimer_State6.Q THEN
			WaitTimer_State6(IN:=FALSE);
			GVL.LogActive := TRUE;
			GVL.LogIndex := 0;
			startFig8 := TRUE;
			//systemState := 7; // proceed to next step
		END_IF
	7: //Figure 8 scan - tracking
		LossTimer(IN := (GVL.power_uw <= 30.0), PT := T#2S);
		IF startFig8 THEN
			fbFigure8Scan(
			Drive1 := GVL.Drive1, Drive2 := GVL.Drive2, Axis1:= Axis1Params, Axis2:= Axis2Params,
            StartScan := startFig8, CurrentPower_uW := GVL.power_uw,
			CenterPan := peakPanDeg, CenterTilt := peakTiltDeg, 
			GlobalMaxPower_uW := GlobalMaxPower_uW);
		END_IF
		IF LossTimer.Q OR doneFig8 THEN
			doneFig8 := TRUE;
			startFig8 := FALSE;
			startSpiral := FALSE;
		END_IF
		IF doneFig8 THEN
			peakPanDeg := fbFigure8Scan.LastPan;
			peakTiltDeg := fbFigure8Scan.LastTilt;
			startFig8 := FALSE;
			startSpiral := FALSE;
			doneFig8 := FALSE;
			waitStart := TRUE;
			firstSpiralExecuted := TRUE;
			startGenerateC3 := FALSE;
			generateSent := FALSE;
		END_IF
		WaitTimer_State7(IN := waitStart, PT := WAIT_TIME);
		IF WaitTimer_State7.Q THEN
			waitStart := FALSE;
			systemState := 3;
		END_IF
	8: 
END_CASE
//// HOLD AT PEAK POSITION for 10s before going back to
			// Start timer once when entering this state
	// 		IF NOT holdMoveSent THEN
	// targetTiltEnc := dposDegToEnc(178.3);
	// targetPanEnc  := dposDegToEnc(-2.45);
	// 			Drive1.MoveAbsolute(targetTiltEnc, drive1Speed, DINT_TO_UINT(drive1Acc), DINT_TO_UINT(drive1Dec));
	// 			Drive2.MoveAbsolute(targetPanEnc, drive2Speed, DINT_TO_UINT(drive2Acc), DINT_TO_UINT(drive2Dec));
	// 			holdMoveSent := TRUE;
	// 			HoldTimer(IN := FALSE);
	// 		END_IF;
	// 		IF NOT Drive1.Busy AND NOT Drive2.Busy THEN
	// 			systemState := 8; // Move to the dedicated DWELL state
	//             holdMoveSent := FALSE; // Ready for next cycle
	// 		END_IF
IF(drive1Halt) THEN
	GVL.Drive1.Halt();
END_IF

IF(drive1Stop) THEN
	GVL.Drive1.Stop();
END_IF
IF(drive1Reset) THEN
	GVL.Drive1.Reset();
END_IF
IF(drive1ResetEncoder) THEN
	GVL.Drive1.ResetEncoder();
END_IF

IF(drive2Halt) THEN
	GVL.Drive2.Halt();
END_IF
IF(drive2Stop) THEN
	GVL.Drive2.Stop();
END_IF
IF(drive2Reset) THEN
	GVL.Drive2.Reset();
END_IF
IF(drive2ResetEncoder) THEN
	GVL.Drive2.ResetEncoder();
END_IF

IF drive1Target THEN
	targetTiltEnc := dposDegToEnc(startTiltDeg);
	GVL.Drive1.MoveAbsolute(targetTiltEnc, drive1Speed, DINT_TO_UINT(drive1Acc), DINT_TO_UINT(drive1Dec));
END_IF
IF drive2Target THEN
	targetPanEnc := dposDegToEnc(startPanDeg);
	GVL.Drive2.MoveAbsolute(targetPanEnc, drive2Speed, DINT_TO_UINT(drive2Acc), DINT_TO_UINT(drive2Dec));
END_IF